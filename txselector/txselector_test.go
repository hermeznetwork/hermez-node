package txselector

import (
	"fmt"
	"io/ioutil"
	"math/big"
	"os"
	"strconv"
	"testing"
	"time"

	ethCommon "github.com/ethereum/go-ethereum/common"
	ethCrypto "github.com/ethereum/go-ethereum/crypto"
	"github.com/hermeznetwork/hermez-node/common"
	"github.com/hermeznetwork/hermez-node/common/nonce"
	dbUtils "github.com/hermeznetwork/hermez-node/db"
	"github.com/hermeznetwork/hermez-node/db/historydb"
	"github.com/hermeznetwork/hermez-node/db/l2db"
	"github.com/hermeznetwork/hermez-node/db/statedb"
	"github.com/hermeznetwork/hermez-node/log"
	"github.com/hermeznetwork/hermez-node/test"
	"github.com/hermeznetwork/hermez-node/test/til"
	"github.com/hermeznetwork/hermez-node/test/txsets"
	"github.com/hermeznetwork/hermez-node/txprocessor"
	"github.com/jmoiron/sqlx"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

var deleteme []string

func TestMain(m *testing.M) {
	exitVal := m.Run()
	for _, dir := range deleteme {
		if err := os.RemoveAll(dir); err != nil {
			panic(err)
		}
	}
	os.Exit(exitVal)
}

func initTest(t *testing.T, chainID uint16, hermezContractAddr ethCommon.Address,
	coordUser *til.User) (*TxSelector, *historydb.HistoryDB, *statedb.StateDB) {
	db, err := dbUtils.InitTestSQLDB()
	require.NoError(t, err)
	l2DB := l2db.NewL2DB(db, db, 10, 100, 0.0, 1000.0, 24*time.Hour, nil)

	historyDB := historydb.NewHistoryDB(db, db, nil)

	dir, err := ioutil.TempDir("", "tmpdb")
	require.NoError(t, err)
	deleteme = append(deleteme, dir)
	syncStateDB, err := statedb.NewStateDB(statedb.Config{Path: dir, Keep: 128,
		Type: statedb.TypeTxSelector, NLevels: 0})
	require.NoError(t, err)

	txselDir, err := ioutil.TempDir("", "tmpTxSelDB")
	require.NoError(t, err)
	deleteme = append(deleteme, txselDir)

	// use Til Coord keys for tests compatibility
	coordAccount := &CoordAccount{
		Addr:                coordUser.Addr,
		BJJ:                 coordUser.BJJ.Public().Compress(),
		AccountCreationAuth: nil,
	}
	// fmt.Printf("%v\n", coordAccount)
	auth := common.AccountCreationAuth{
		EthAddr: coordUser.Addr,
		BJJ:     coordUser.BJJ.Public().Compress(),
	}
	err = auth.Sign(func(hash []byte) ([]byte, error) {
		return ethCrypto.Sign(hash, coordUser.EthSk)
	}, chainID, hermezContractAddr)
	assert.NoError(t, err)
	coordAccount.AccountCreationAuth = auth.Signature

	txsel, err := NewTxSelector(coordAccount, txselDir, syncStateDB, l2DB)
	require.NoError(t, err)

	test.WipeDB(txsel.l2db.DB())

	return txsel, historyDB, syncStateDB
}

func addAccCreationAuth(t *testing.T, tc *til.Context, txsel *TxSelector, chainID uint16,
	hermezContractAddr ethCommon.Address, username string) []byte {
	user := tc.Users[username]
	auth := &common.AccountCreationAuth{
		EthAddr: user.Addr,
		BJJ:     user.BJJ.Public().Compress(),
	}
	err := auth.Sign(func(hash []byte) ([]byte, error) {
		return ethCrypto.Sign(hash, user.EthSk)
	}, chainID, hermezContractAddr)
	assert.NoError(t, err)

	err = txsel.l2db.AddAccountCreationAuth(auth)
	assert.NoError(t, err)
	return auth.Signature
}

func addL2Txs(t *testing.T, txsel *TxSelector, poolL2Txs []common.PoolL2Tx) {
	for i := 0; i < len(poolL2Txs); i++ {
		err := txsel.l2db.AddTxTest(&poolL2Txs[i])
		if err != nil {
			log.Error(err)
		}
		require.NoError(t, err)
	}
}

func addTokens(t *testing.T, tc *til.Context, db *sqlx.DB) {
	var tokens []common.Token
	for i := 0; i < int(tc.LastRegisteredTokenID); i++ {
		tokens = append(tokens, common.Token{
			TokenID:     common.TokenID(i + 1),
			EthBlockNum: 1,
			EthAddr:     ethCommon.BytesToAddress([]byte{byte(i + 1)}),
			Name:        strconv.Itoa(i),
			Symbol:      strconv.Itoa(i),
			Decimals:    18,
		})
	}

	hdb := historydb.NewHistoryDB(db, db, nil)
	assert.NoError(t, hdb.AddBlock(&common.Block{
		Num: 1,
	}))
	assert.NoError(t, hdb.AddTokens(tokens))
}

func checkBalance(t *testing.T, tc *til.Context, txsel *TxSelector, username string,
	tokenid int, expected string) {
	// Accounts.Idx does not match with the TxSelector tests as we are not
	// using the Til L1CoordinatorTxs (as are generated by the TxSelector
	// itself when processing the txs, so the Idxs does not match the Til
	// idxs). But the Idx is obtained through StateDB.GetIdxByEthAddrBJJ
	user := tc.Users[username]
	idx, err := txsel.localAccountsDB.GetIdxByEthAddrBJJ(user.Addr, user.BJJ.Public().Compress(),
		common.TokenID(tokenid))
	require.NoError(t, err)
	checkBalanceByIdx(t, txsel, idx, expected)
}

func checkBalanceByIdx(t *testing.T, txsel *TxSelector, idx common.Idx, expected string) {
	acc, err := txsel.localAccountsDB.GetAccount(idx)
	require.NoError(t, err)
	assert.Equal(t, expected, acc.Balance.String())
}

// checkSortedByNonce takes as input testAccNonces map, and the array of
// common.PoolL2Txs, and checks if the nonces correspond to the accumulated
// values of the map. Also increases the Nonces computed on the map.
func checkSortedByNonce(t *testing.T, testAccNonces map[common.Idx]nonce.Nonce,
	txs []common.PoolL2Tx) {
	for _, tx := range txs {
		assert.True(t, testAccNonces[tx.FromIdx] == tx.Nonce,
			fmt.Sprintf("Idx: %d, expected: %d, tx.Nonce: %d",
				tx.FromIdx, testAccNonces[tx.FromIdx], tx.Nonce))
		testAccNonces[tx.FromIdx] = testAccNonces[tx.FromIdx] + 1
	}
}

func TestGetL2TxSelectionMinimumFlow0(t *testing.T) {
	chainID := uint16(0)
	tc := til.NewContext(chainID, common.RollupConstMaxL1UserTx)
	// generate test transactions, the L1CoordinatorTxs generated by Til
	// will be ignored at this test, as will be the TxSelector who
	// generates them when needed
	blocks, err := tc.GenerateBlocks(txsets.SetBlockchainMinimumFlow0)
	assert.NoError(t, err)

	hermezContractAddr := ethCommon.HexToAddress("0xc344E203a046Da13b0B4467EB7B3629D0C99F6E6")
	txsel, _, stateDB := initTest(t, chainID, hermezContractAddr, tc.Users["Coord"])

	// restart nonces of TilContext, as will be set by generating directly
	// the PoolL2Txs for each specific batch with tc.GeneratePoolL2Txs
	tc.RestartNonces()
	testAccNonces := make(map[common.Idx]nonce.Nonce)

	// add tokens to HistoryDB to avoid breaking FK constrains
	addTokens(t, tc, txsel.l2db.DB())

	tpc := txprocessor.Config{
		NLevels:  16,
		MaxFeeTx: 10,
		MaxTx:    20,
		MaxL1Tx:  10,
		ChainID:  chainID,
	}

	// coordIdxs, accAuths, l1UserTxs, l1CoordTxs, l2Txs, err

	log.Debug("block:0 batch:1")
	l1UserTxs := []common.L1Tx{}
	_, _, oL1UserTxs, oL1CoordTxs, oL2Txs, _, err :=
		txsel.GetL1L2TxSelection(tpc, l1UserTxs, nil)
	require.NoError(t, err)
	assert.Equal(t, 0, len(oL1UserTxs))
	assert.Equal(t, 0, len(oL1CoordTxs))
	assert.Equal(t, 0, len(oL2Txs))
	assert.Equal(t, common.BatchNum(1), txsel.localAccountsDB.CurrentBatch())
	assert.Equal(t, common.Idx(255), txsel.localAccountsDB.CurrentIdx())

	log.Debug("block:0 batch:2")
	l1UserTxs = []common.L1Tx{}
	_, _, oL1UserTxs, oL1CoordTxs, oL2Txs, _, err =
		txsel.GetL1L2TxSelection(tpc, l1UserTxs, nil)
	require.NoError(t, err)
	assert.Equal(t, 0, len(oL1UserTxs))
	assert.Equal(t, 0, len(oL1CoordTxs))
	assert.Equal(t, 0, len(oL2Txs))
	assert.Equal(t, common.BatchNum(2), txsel.localAccountsDB.CurrentBatch())
	assert.Equal(t, common.Idx(255), txsel.localAccountsDB.CurrentIdx())

	log.Debug("block:0 batch:3")
	l1UserTxs = til.L1TxsToCommonL1Txs(tc.Queues[*blocks[0].Rollup.Batches[2].Batch.ForgeL1TxsNum])
	_, _, oL1UserTxs, oL1CoordTxs, oL2Txs, _, err =
		txsel.GetL1L2TxSelection(tpc, l1UserTxs, nil)
	require.NoError(t, err)
	assert.Equal(t, 2, len(oL1UserTxs))
	assert.Equal(t, 0, len(oL1CoordTxs))
	assert.Equal(t, 0, len(oL2Txs))
	assert.Equal(t, common.BatchNum(3), txsel.localAccountsDB.CurrentBatch())
	assert.Equal(t, common.Idx(257), txsel.localAccountsDB.CurrentIdx())
	checkBalance(t, tc, txsel, "A", 0, "500")
	checkBalance(t, tc, txsel, "C", 1, "0")

	log.Debug("block:0 batch:4")
	l1UserTxs = til.L1TxsToCommonL1Txs(tc.Queues[*blocks[0].Rollup.Batches[3].Batch.ForgeL1TxsNum])
	_, _, oL1UserTxs, oL1CoordTxs, oL2Txs, _, err =
		txsel.GetL1L2TxSelection(tpc, l1UserTxs, nil)
	require.NoError(t, err)
	assert.Equal(t, 1, len(oL1UserTxs))
	assert.Equal(t, 0, len(oL1CoordTxs))
	assert.Equal(t, 0, len(oL2Txs))
	assert.Equal(t, common.BatchNum(4), txsel.localAccountsDB.CurrentBatch())
	assert.Equal(t, common.Idx(258), txsel.localAccountsDB.CurrentIdx())
	checkBalance(t, tc, txsel, "A", 0, "500")
	checkBalance(t, tc, txsel, "A", 1, "500")
	checkBalance(t, tc, txsel, "C", 1, "0")

	log.Debug("block:0 batch:5")
	l1UserTxs = til.L1TxsToCommonL1Txs(tc.Queues[*blocks[0].Rollup.Batches[4].Batch.ForgeL1TxsNum])
	_, _, oL1UserTxs, oL1CoordTxs, oL2Txs, _, err =
		txsel.GetL1L2TxSelection(tpc, l1UserTxs, nil)
	require.NoError(t, err)
	assert.Equal(t, 0, len(oL1UserTxs))
	assert.Equal(t, 0, len(oL1CoordTxs))
	assert.Equal(t, 0, len(oL2Txs))
	assert.Equal(t, common.BatchNum(5), txsel.localAccountsDB.CurrentBatch())
	assert.Equal(t, common.Idx(258), txsel.localAccountsDB.CurrentIdx())
	checkBalance(t, tc, txsel, "A", 0, "500")
	checkBalance(t, tc, txsel, "A", 1, "500")
	checkBalance(t, tc, txsel, "C", 1, "0")

	log.Debug("block:0 batch:6")
	l1UserTxs = til.L1TxsToCommonL1Txs(tc.Queues[*blocks[0].Rollup.Batches[5].Batch.ForgeL1TxsNum])
	_, _, oL1UserTxs, oL1CoordTxs, oL2Txs, _, err =
		txsel.GetL1L2TxSelection(tpc, l1UserTxs, nil)
	require.NoError(t, err)
	assert.Equal(t, 1, len(oL1UserTxs))
	assert.Equal(t, 0, len(oL1CoordTxs))
	assert.Equal(t, 0, len(oL2Txs))
	assert.Equal(t, common.BatchNum(6), txsel.localAccountsDB.CurrentBatch())
	assert.Equal(t, common.Idx(259), txsel.localAccountsDB.CurrentIdx())
	checkBalance(t, tc, txsel, "A", 0, "600")
	checkBalance(t, tc, txsel, "A", 1, "500")
	checkBalance(t, tc, txsel, "B", 0, "400")
	checkBalance(t, tc, txsel, "C", 1, "0")

	log.Debug("block:0 batch:7")
	// simulate the PoolL2Txs of the batch7
	batchPoolL2 := `
	Type: PoolL2
	PoolTransferToEthAddr(1) A-B: 200 (126)
	PoolTransferToEthAddr(0) B-C: 100 (126)`
	poolL2Txs, err := tc.GeneratePoolL2Txs(batchPoolL2)
	require.NoError(t, err)
	// add AccountCreationAuths that will be used at the next batch
	accAuthSig0 := addAccCreationAuth(t, tc, txsel, chainID, hermezContractAddr, "B")
	accAuthSig1 := addAccCreationAuth(t, tc, txsel, chainID, hermezContractAddr, "C")
	// add the PoolL2Txs to the l2DB
	addL2Txs(t, txsel, poolL2Txs)
	// check signatures of L2Txs from the L2DB (to check that the
	// parameters of the PoolL2Tx match the original parameters signed
	// before inserting it to the L2DB)
	l2TxsFromDB, err := txsel.l2db.GetPendingTxs()
	require.NoError(t, err)
	assert.True(t, l2TxsFromDB[0].VerifySignature(chainID, tc.Users["A"].BJJ.Public().Compress()))
	assert.True(t, l2TxsFromDB[1].VerifySignature(chainID, tc.Users["B"].BJJ.Public().Compress()))
	l1UserTxs = til.L1TxsToCommonL1Txs(tc.Queues[*blocks[0].Rollup.Batches[6].Batch.ForgeL1TxsNum])
	coordIdxs, accAuths, oL1UserTxs, oL1CoordTxs, oL2Txs, discardedL2Txs, err :=
		txsel.GetL1L2TxSelection(tpc, l1UserTxs, nil)
	require.NoError(t, err)
	assert.Equal(t, []common.Idx{261, 263}, coordIdxs)
	assert.Equal(t, txsel.coordAccount.AccountCreationAuth, accAuths[0])
	assert.Equal(t, txsel.coordAccount.AccountCreationAuth, accAuths[2])
	assert.Equal(t, accAuthSig0, accAuths[1])
	assert.Equal(t, accAuthSig1, accAuths[3])
	assert.Equal(t, 1, len(oL1UserTxs))
	assert.Equal(t, 4, len(oL1CoordTxs))
	assert.Equal(t, 2, len(oL2Txs))
	assert.Equal(t, 0, len(discardedL2Txs))
	assert.Equal(t, len(oL1CoordTxs), len(accAuths))
	assert.Equal(t, common.BatchNum(7), txsel.localAccountsDB.CurrentBatch())
	assert.Equal(t, common.Idx(264), txsel.localAccountsDB.CurrentIdx())
	checkBalance(t, tc, txsel, "Coord", 1, "20") // CoordIdx for TokenID=1
	checkBalance(t, tc, txsel, "Coord", 0, "10") // CoordIdx for TokenID=1
	checkBalance(t, tc, txsel, "A", 0, "600")
	checkBalance(t, tc, txsel, "A", 1, "280")
	checkBalance(t, tc, txsel, "B", 0, "290")
	checkBalance(t, tc, txsel, "B", 1, "200")
	checkBalance(t, tc, txsel, "C", 0, "100")
	checkBalance(t, tc, txsel, "D", 0, "800")
	checkSortedByNonce(t, testAccNonces, oL2Txs)
	err = txsel.l2db.StartForging(common.TxIDsFromPoolL2Txs(poolL2Txs),
		txsel.localAccountsDB.CurrentBatch())
	require.NoError(t, err)

	log.Debug("block:0 batch:8")
	// simulate the PoolL2Txs of the batch8
	batchPoolL2 = `
	Type: PoolL2
	PoolTransfer(0) A-B: 100 (126)
	PoolTransfer(0) C-A: 50 (126)
	PoolTransfer(1) B-C: 100 (126)
	PoolExit(0) A: 100 (126)`
	poolL2Txs, err = tc.GeneratePoolL2Txs(batchPoolL2)
	require.NoError(t, err)
	addL2Txs(t, txsel, poolL2Txs)
	// check signatures of L2Txs from the L2DB (to check that the
	// parameters of the PoolL2Tx match the original parameters signed
	// before inserting it to the L2DB)
	l2TxsFromDB, err = txsel.l2db.GetPendingTxs()
	require.NoError(t, err)
	assert.True(t, l2TxsFromDB[0].VerifySignature(chainID, tc.Users["A"].BJJ.Public().Compress()))
	assert.True(t, l2TxsFromDB[1].VerifySignature(chainID, tc.Users["C"].BJJ.Public().Compress()))
	assert.True(t, l2TxsFromDB[2].VerifySignature(chainID, tc.Users["B"].BJJ.Public().Compress()))
	assert.True(t, l2TxsFromDB[3].VerifySignature(chainID, tc.Users["A"].BJJ.Public().Compress()))
	l1UserTxs = til.L1TxsToCommonL1Txs(tc.Queues[*blocks[0].Rollup.Batches[7].Batch.ForgeL1TxsNum])
	coordIdxs, accAuths, oL1UserTxs, oL1CoordTxs, oL2Txs, discardedL2Txs, err =
		txsel.GetL1L2TxSelection(tpc, l1UserTxs, nil)
	require.NoError(t, err)
	assert.Equal(t, []common.Idx{261, 263}, coordIdxs)
	assert.Equal(t, 0, len(accAuths))
	assert.Equal(t, 0, len(oL1UserTxs))
	assert.Equal(t, 0, len(oL1CoordTxs))
	assert.Equal(t, 4, len(oL2Txs))
	assert.Equal(t, 0, len(discardedL2Txs))
	assert.Equal(t, len(oL1CoordTxs), len(accAuths))
	assert.Equal(t, common.BatchNum(8), txsel.localAccountsDB.CurrentBatch())
	assert.Equal(t, common.Idx(264), txsel.localAccountsDB.CurrentIdx())
	checkBalance(t, tc, txsel, "Coord", 1, "30") // CoordIdx for TokenID=1
	checkBalance(t, tc, txsel, "Coord", 0, "35") // CoordIdx for TokenID=1
	checkBalance(t, tc, txsel, "A", 0, "430")
	checkBalance(t, tc, txsel, "A", 1, "280")
	checkBalance(t, tc, txsel, "B", 0, "390")
	checkBalance(t, tc, txsel, "B", 1, "90")
	checkBalance(t, tc, txsel, "C", 0, "45")
	checkBalance(t, tc, txsel, "C", 1, "100")
	checkBalance(t, tc, txsel, "D", 0, "800")
	checkSortedByNonce(t, testAccNonces, oL2Txs)
	err = txsel.l2db.StartForging(common.TxIDsFromPoolL2Txs(poolL2Txs),
		txsel.localAccountsDB.CurrentBatch())
	require.NoError(t, err)

	log.Debug("(batch9)block:1 batch:1")
	// simulate the PoolL2Txs of the batch9
	batchPoolL2 = `
	Type: PoolL2
	PoolTransfer(0) D-A: 300 (126)
	PoolTransfer(0) B-D: 100 (126)
	`
	poolL2Txs, err = tc.GeneratePoolL2Txs(batchPoolL2)
	require.NoError(t, err)
	addL2Txs(t, txsel, poolL2Txs)
	// check signatures of L2Txs from the L2DB (to check that the
	// parameters of the PoolL2Tx match the original parameters signed
	// before inserting it to the L2DB)
	l2TxsFromDB, err = txsel.l2db.GetPendingTxs()
	require.NoError(t, err)
	assert.True(t, l2TxsFromDB[0].VerifySignature(chainID, tc.Users["D"].BJJ.Public().Compress()))
	assert.True(t, l2TxsFromDB[1].VerifySignature(chainID, tc.Users["B"].BJJ.Public().Compress()))
	l1UserTxs = til.L1TxsToCommonL1Txs(tc.Queues[*blocks[1].Rollup.Batches[0].Batch.ForgeL1TxsNum])
	coordIdxs, accAuths, oL1UserTxs, oL1CoordTxs, oL2Txs, _, err =
		txsel.GetL1L2TxSelection(tpc, l1UserTxs, nil)
	require.NoError(t, err)
	assert.Equal(t, []common.Idx{263}, coordIdxs)
	assert.Equal(t, 0, len(accAuths))
	assert.Equal(t, 4, len(oL1UserTxs))
	assert.Equal(t, 0, len(oL1CoordTxs))
	assert.Equal(t, 2, len(oL2Txs))
	assert.Equal(t, len(oL1CoordTxs), len(accAuths))
	assert.Equal(t, common.BatchNum(9), txsel.localAccountsDB.CurrentBatch())
	assert.Equal(t, common.Idx(264), txsel.localAccountsDB.CurrentIdx())
	checkBalanceByIdx(t, txsel, 261, "30")
	checkBalanceByIdx(t, txsel, 263, "75")
	checkBalance(t, tc, txsel, "A", 0, "730")
	checkBalance(t, tc, txsel, "A", 1, "280")
	checkBalance(t, tc, txsel, "B", 0, "380")
	checkBalance(t, tc, txsel, "B", 1, "90")
	checkBalance(t, tc, txsel, "C", 0, "845")
	checkBalance(t, tc, txsel, "C", 1, "100")
	checkBalance(t, tc, txsel, "D", 0, "470")
	checkSortedByNonce(t, testAccNonces, oL2Txs)
	err = txsel.l2db.StartForging(common.TxIDsFromPoolL2Txs(poolL2Txs),
		txsel.localAccountsDB.CurrentBatch())
	require.NoError(t, err)

	stateDB.Close()
	txsel.LocalAccountsDB().Close()
}

func TestTransferToBjj(t *testing.T) {
	set := `
		Type: Blockchain
		AddToken(1)

		CreateAccountDeposit(0) Coord: 0
		CreateAccountDeposit(0) A: 1000
		CreateAccountDeposit(0) B: 1000
		CreateAccountDeposit(1) B: 1000

		> batchL1 // freeze L1User{4}
		> batchL1 // forge L1User{4}
		> block
	`

	chainID := uint16(0)
	tc := til.NewContext(chainID, common.RollupConstMaxL1UserTx)
	blocks, err := tc.GenerateBlocks(set)
	assert.NoError(t, err)

	hermezContractAddr := ethCommon.HexToAddress("0xc344E203a046Da13b0B4467EB7B3629D0C99F6E6")
	txsel, _, stateDB := initTest(t, chainID, hermezContractAddr, tc.Users["Coord"])

	// restart nonces of TilContext, as will be set by generating directly
	// the PoolL2Txs for each specific batch with tc.GeneratePoolL2Txs
	tc.RestartNonces()

	addTokens(t, tc, txsel.l2db.DB())

	tpc := txprocessor.Config{
		NLevels:  16,
		MaxFeeTx: 10,
		MaxTx:    20,
		MaxL1Tx:  10,
		ChainID:  chainID,
	}
	// batch1 to freeze L1UserTxs that will create some accounts with
	// positive balance
	l1UserTxs := []common.L1Tx{}
	_, _, _, _, _, _, err = txsel.GetL1L2TxSelection(tpc, l1UserTxs, nil)
	require.NoError(t, err)

	// Transfer is ToBJJ to a BJJ-only account that doesn't exist
	// and the coordinator will create it via L1CoordTx.

	batchPoolL2 := `
	Type: PoolL2
	PoolTransferToBJJ(0) A-B: 50 (126)
	`
	poolL2Txs, err := tc.GeneratePoolL2Txs(batchPoolL2)
	require.NoError(t, err)

	// add the PoolL2Txs to the l2DB
	addL2Txs(t, txsel, poolL2Txs)

	l1UserTxs = til.L1TxsToCommonL1Txs(tc.Queues[*blocks[0].Rollup.Batches[1].Batch.ForgeL1TxsNum])
	_, _, oL1UserTxs, oL1CoordTxs, oL2Txs, discardedL2Txs, err :=
		txsel.GetL1L2TxSelection(tpc, l1UserTxs, nil)
	require.NoError(t, err)
	assert.Equal(t, 4, len(oL1UserTxs))
	// We expect the coordinator to add an L1CoordTx to create an account for the recipient of the l2tx
	require.Equal(t, 1, len(oL1CoordTxs))
	assert.Equal(t, poolL2Txs[0].ToEthAddr, oL1CoordTxs[0].FromEthAddr)
	assert.Equal(t, poolL2Txs[0].ToBJJ, oL1CoordTxs[0].FromBJJ)
	assert.Equal(t, 1, len(oL2Txs))
	assert.Equal(t, 0, len(discardedL2Txs))
	err = txsel.l2db.StartForging(common.TxIDsFromPoolL2Txs(oL2Txs),
		txsel.localAccountsDB.CurrentBatch())
	require.NoError(t, err)

	// Now the BJJ-only account for B is already created, so the transfer
	// happens without an L1CoordTx that creates the user account.

	batchPoolL2 = `
	Type: PoolL2
	PoolTransferToBJJ(0) A-B: 50 (126)
	`

	poolL2Txs, err = tc.GeneratePoolL2Txs(batchPoolL2)
	require.NoError(t, err)
	addL2Txs(t, txsel, poolL2Txs)

	l1UserTxs = []common.L1Tx{}
	_, _, oL1UserTxs, oL1CoordTxs, oL2Txs, discardedL2Txs, err =
		txsel.GetL1L2TxSelection(tpc, l1UserTxs, nil)
	require.NoError(t, err)
	assert.Equal(t, 0, len(oL1UserTxs))
	// Since the BJJ-only account B already exists, the coordinator doesn't add any L1CoordTxs
	assert.Equal(t, 0, len(oL1CoordTxs))
	assert.Equal(t, 1, len(oL2Txs))
	assert.Equal(t, 0, len(discardedL2Txs))
	err = txsel.l2db.StartForging(common.TxIDsFromPoolL2Txs(oL2Txs),
		txsel.localAccountsDB.CurrentBatch())
	require.NoError(t, err)

	// The transfer now is ToBJJ to a BJJ-only account that doesn't exist
	// and the coordinator will create it via L1CoordTx.   Since it's a
	// transfer of a token for which the coordinator doesn't have a fee
	// account, another L1CoordTx will be created for the coordinator to
	// receive the fees.

	batchPoolL2 = `
	Type: PoolL2
	PoolTransferToBJJ(1) B-A: 50 (126)
	`

	poolL2Txs, err = tc.GeneratePoolL2Txs(batchPoolL2)
	require.NoError(t, err)
	addL2Txs(t, txsel, poolL2Txs)

	l1UserTxs = []common.L1Tx{}
	_, _, oL1UserTxs, oL1CoordTxs, oL2Txs, discardedL2Txs, err =
		txsel.GetL1L2TxSelection(tpc, l1UserTxs, nil)
	require.NoError(t, err)
	assert.Equal(t, 0, len(oL1UserTxs))
	// We expect the coordinator to add an L1CoordTx to create an account
	// to receive the fees by the coordinator and another one for the
	// recipient of the l2tx
	assert.Equal(t, 2, len(oL1CoordTxs))
	// [0] Coordinator account cration for token 1
	assert.Equal(t, tc.Users["Coord"].Addr, oL1CoordTxs[0].FromEthAddr)
	// [1] User A BJJ-only account creation for token 1
	assert.Equal(t, poolL2Txs[0].ToEthAddr, oL1CoordTxs[1].FromEthAddr)
	assert.Equal(t, poolL2Txs[0].ToBJJ, oL1CoordTxs[1].FromBJJ)
	assert.Equal(t, common.TokenID(1), oL1CoordTxs[1].TokenID)

	assert.Equal(t, 1, len(oL2Txs))
	assert.Equal(t, 0, len(discardedL2Txs))
	err = txsel.l2db.StartForging(common.TxIDsFromPoolL2Txs(oL2Txs),
		txsel.localAccountsDB.CurrentBatch())
	require.NoError(t, err)

	stateDB.Close()
	txsel.LocalAccountsDB().Close()
}

func TestTransferManyFromSameAccount(t *testing.T) {
	set := `
		Type: Blockchain

		CreateAccountDeposit(0) Coord: 0
		CreateAccountDeposit(0) A: 1000
		CreateAccountDeposit(0) B: 1000

		> batchL1 // freeze L1User{3}
		> batchL1 // forge L1User{3}
		> block
	`

	chainID := uint16(0)
	tc := til.NewContext(chainID, common.RollupConstMaxL1UserTx)
	blocks, err := tc.GenerateBlocks(set)
	assert.NoError(t, err)

	hermezContractAddr := ethCommon.HexToAddress("0xc344E203a046Da13b0B4467EB7B3629D0C99F6E6")
	txsel, _, stateDB := initTest(t, chainID, hermezContractAddr, tc.Users["Coord"])

	// restart nonces of TilContext, as will be set by generating directly
	// the PoolL2Txs for each specific batch with tc.GeneratePoolL2Txs
	tc.RestartNonces()

	tpc := txprocessor.Config{
		NLevels:  16,
		MaxFeeTx: 10,
		MaxTx:    10,
		MaxL1Tx:  10,
		ChainID:  chainID,
	}
	// batch1 to freeze L1UserTxs
	l1UserTxs := []common.L1Tx{}
	_, _, _, _, _, _, err = txsel.GetL1L2TxSelection(tpc, l1UserTxs, nil)
	require.NoError(t, err)

	// 8 transfers from the same account
	batchPoolL2 := `
	Type: PoolL2
	PoolTransfer(0) A-B: 10 (126) // 1
	PoolTransfer(0) A-B: 10 (126) // 2
	PoolTransfer(0) A-B: 10 (126) // 3
	PoolTransfer(0) A-B: 10 (126) // 4
	PoolTransfer(0) A-B: 10 (126) // 5
	PoolTransfer(0) A-B: 10 (126) // 6
	PoolTransfer(0) A-B: 10 (126) // 7
	PoolTransfer(0) A-B: 10 (126) // 8
	PoolTransfer(0) A-B: 10 (126) // 9
	PoolTransfer(0) A-B: 10 (126) // 10
	PoolTransfer(0) A-B: 10 (126) // 11
	`
	poolL2Txs, err := tc.GeneratePoolL2Txs(batchPoolL2)
	require.NoError(t, err)
	require.Equal(t, 11, len(poolL2Txs))

	// reorder poolL2Txs so that nonces are not sorted
	poolL2Txs[0], poolL2Txs[7] = poolL2Txs[7], poolL2Txs[0]
	poolL2Txs[1], poolL2Txs[10] = poolL2Txs[10], poolL2Txs[1]

	// add the PoolL2Txs to the l2DB
	addL2Txs(t, txsel, poolL2Txs)
	// batch 2 to crate some accounts with positive balance, and do 8 L2Tx
	// transfers from account A
	l1UserTxs = til.L1TxsToCommonL1Txs(tc.Queues[*blocks[0].Rollup.Batches[1].Batch.ForgeL1TxsNum])
	_, _, oL1UserTxs, oL1CoordTxs, oL2Txs, discardedL2Txs, err :=
		txsel.GetL1L2TxSelection(tpc, l1UserTxs, nil)
	require.NoError(t, err)
	assert.Equal(t, 3, len(oL1UserTxs))
	require.Equal(t, 0, len(oL1CoordTxs))
	assert.Equal(t, 7, len(oL2Txs))
	assert.Equal(t, 4, len(discardedL2Txs))

	err = txsel.l2db.StartForging(common.TxIDsFromPoolL2Txs(oL2Txs),
		txsel.localAccountsDB.CurrentBatch())
	require.NoError(t, err)

	stateDB.Close()
	txsel.LocalAccountsDB().Close()
}

func TestPoolL2TxInvalidNonces(t *testing.T) {
	// This test recreates the case where L2Txs of type TransferToEthAddr
	// for non existing accounts are not selected due not enough space for
	// the needed L1CoordinatorTxs (of account creation).

	set := `
		Type: Blockchain

		CreateAccountDeposit(0) Coord: 0
		CreateAccountDeposit(0) A: 100000
		CreateAccountDeposit(0) B: 10000

		> batchL1 // Batch1: freeze L1User{3}
		> batchL1 // Batch2: forge L1User{3}
		> block
	`

	chainID := uint16(0)
	tc := til.NewContext(chainID, common.RollupConstMaxL1UserTx)
	blocks, err := tc.GenerateBlocks(set)
	assert.NoError(t, err)

	hermezContractAddr := ethCommon.HexToAddress("0xc344E203a046Da13b0B4467EB7B3629D0C99F6E6")
	txsel, _, stateDB := initTest(t, chainID, hermezContractAddr, tc.Users["Coord"])

	// restart nonces of TilContext, as will be set by generating directly
	// the PoolL2Txs for each specific batch with tc.GeneratePoolL2Txs
	tc.RestartNonces()

	tpc := txprocessor.Config{
		NLevels:  16,
		MaxFeeTx: 10,
		MaxTx:    20,
		MaxL1Tx:  3,
		ChainID:  chainID,
	}
	// batch1 to freeze L1UserTxs
	l1UserTxs := []common.L1Tx{}
	_, _, _, _, _, _, err = txsel.GetL1L2TxSelection(tpc, l1UserTxs, nil)
	require.NoError(t, err)

	batchPoolL2 := `
	Type: PoolL2
	PoolTransferToEthAddr(0) B-C: 10 (126)
	PoolTransfer(0) B-A: 10 (126)
	PoolTransferToEthAddr(0) B-D: 10 (126)
	PoolTransfer(0) B-A: 10 (126)
	PoolTransferToEthAddr(0) B-E: 10 (126)
	PoolTransfer(0) B-A: 10 (126)
	PoolTransferToEthAddr(0) B-F: 10 (126)
	PoolTransfer(0) B-A: 10 (126)
	PoolTransferToEthAddr(0) B-G: 10 (126)
	PoolTransfer(0) B-A: 10 (126)
	`
	poolL2Txs, err := tc.GeneratePoolL2Txs(batchPoolL2)
	require.NoError(t, err)
	require.Equal(t, 10, len(poolL2Txs))

	// add AccountCreationAuths that will be used at the next batch
	_ = addAccCreationAuth(t, tc, txsel, chainID, hermezContractAddr, "C")
	_ = addAccCreationAuth(t, tc, txsel, chainID, hermezContractAddr, "D")
	_ = addAccCreationAuth(t, tc, txsel, chainID, hermezContractAddr, "E")
	_ = addAccCreationAuth(t, tc, txsel, chainID, hermezContractAddr, "F")
	_ = addAccCreationAuth(t, tc, txsel, chainID, hermezContractAddr, "G")

	// add the PoolL2Txs to the l2DB
	addL2Txs(t, txsel, poolL2Txs)
	// batch 2 to crate the accounts (from L1UserTxs)
	l1UserTxs = til.L1TxsToCommonL1Txs(tc.Queues[*blocks[0].Rollup.Batches[1].Batch.ForgeL1TxsNum])

	// select L1 & L2 txs
	_, accAuths, oL1UserTxs, oL1CoordTxs, oL2Txs, discardedL2Txs, err :=
		txsel.GetL1L2TxSelection(tpc, l1UserTxs, nil)
	require.NoError(t, err)
	require.Equal(t, 3, len(oL1UserTxs))
	require.Equal(t, 0, len(oL1CoordTxs))
	require.Equal(t, 2, len(oL2Txs))
	require.Equal(t, 8, len(discardedL2Txs))
	require.Equal(t, 0, len(accAuths))

	err = txsel.l2db.StartForging(common.TxIDsFromPoolL2Txs(oL2Txs),
		txsel.localAccountsDB.CurrentBatch())
	require.NoError(t, err)

	// batch 3
	l1UserTxs = []common.L1Tx{}
	_, accAuths, oL1UserTxs, oL1CoordTxs, oL2Txs, discardedL2Txs, err =
		txsel.GetL1L2TxSelection(tpc, l1UserTxs, nil)
	require.NoError(t, err)

	require.Equal(t, 0, len(oL1UserTxs))
	require.Equal(t, 3, len(oL1CoordTxs))
	require.Equal(t, 6, len(oL2Txs))
	require.Equal(t, 2, len(discardedL2Txs))
	require.Equal(t, 3, len(accAuths))

	err = txsel.l2db.StartForging(common.TxIDsFromPoolL2Txs(oL2Txs),
		txsel.localAccountsDB.CurrentBatch())
	require.NoError(t, err)

	// batch 4
	l1UserTxs = []common.L1Tx{}
	_, accAuths, oL1UserTxs, oL1CoordTxs, oL2Txs, discardedL2Txs, err =
		txsel.GetL1L2TxSelection(tpc, l1UserTxs, nil)
	require.NoError(t, err)

	require.Equal(t, 0, len(oL1UserTxs))
	require.Equal(t, 1, len(oL1CoordTxs))
	require.Equal(t, 2, len(oL2Txs))
	require.Equal(t, 0, len(discardedL2Txs))
	require.Equal(t, 1, len(accAuths))

	err = txsel.l2db.StartForging(common.TxIDsFromPoolL2Txs(oL2Txs),
		txsel.localAccountsDB.CurrentBatch())
	require.NoError(t, err)

	stateDB.Close()
	txsel.LocalAccountsDB().Close()
}

func TestProcessL2Selection(t *testing.T) {
	set := `
		Type: Blockchain

		CreateAccountDeposit(0) Coord: 0
		CreateAccountDeposit(0) A: 18
		CreateAccountDeposit(0) B: 0

		> batchL1 // freeze L1User{3}
		> batchL1 // forge L1User{3}
		> block
	`

	chainID := uint16(0)
	tc := til.NewContext(chainID, common.RollupConstMaxL1UserTx)
	blocks, err := tc.GenerateBlocks(set)
	assert.NoError(t, err)

	hermezContractAddr := ethCommon.HexToAddress("0xc344E203a046Da13b0B4467EB7B3629D0C99F6E6")
	txsel, _, stateDB := initTest(t, chainID, hermezContractAddr, tc.Users["Coord"])

	// restart nonces of TilContext, as will be set by generating directly
	// the PoolL2Txs for each specific batch with tc.GeneratePoolL2Txs
	tc.RestartNonces()

	tpc := txprocessor.Config{
		NLevels:  16,
		MaxFeeTx: 10,
		MaxTx:    10,
		MaxL1Tx:  10,
		ChainID:  chainID,
	}
	// batch1 to freeze L1UserTxs
	l1UserTxs := []common.L1Tx{}
	_, _, _, _, _, _, err = txsel.GetL1L2TxSelection(tpc, l1UserTxs, nil)
	require.NoError(t, err)

	// 3 transfers from the same account
	batchPoolL2 := `
	Type: PoolL2
	PoolTransfer(0) A-B: 10 (126)
	PoolTransfer(0) A-B: 10 (126) // not enough funds
	PoolTransfer(0) A-B: 5 (126) // enough funds
	`
	poolL2Txs, err := tc.GeneratePoolL2Txs(batchPoolL2)
	require.NoError(t, err)
	require.Equal(t, 3, len(poolL2Txs))

	// add the PoolL2Txs to the l2DB
	addL2Txs(t, txsel, poolL2Txs)
	// batch 2 to crate some accounts with positive balance, and do 3 L2Tx transfers from account A
	l1UserTxs = til.L1TxsToCommonL1Txs(tc.Queues[*blocks[0].Rollup.Batches[1].Batch.ForgeL1TxsNum])
	_, _, oL1UserTxs, oL1CoordTxs, oL2Txs, discardedL2Txs, err :=
		txsel.GetL1L2TxSelection(tpc, l1UserTxs, nil)
	require.NoError(t, err)
	assert.Equal(t, 3, len(oL1UserTxs))
	require.Equal(t, 0, len(oL1CoordTxs))
	// only 1st L2Tx should be accepted, as:
	// - 2nd will not be selected as has not enough funds
	// - 3rd will not be selected as has Nonce=2, and the account Nonce==1
	// (due the 2nd txs not being accepted)
	assert.Equal(t, 1, len(oL2Txs))
	assert.Equal(t, 2, len(discardedL2Txs))
	assert.Equal(t, nonce.Nonce(0), oL2Txs[0].Nonce)
	assert.Equal(t, nonce.Nonce(1), discardedL2Txs[0].Nonce)
	assert.Equal(t, nonce.Nonce(2), discardedL2Txs[1].Nonce)
	assert.Equal(t, "Tx not selected due to not enough Balance at the sender. "+
		"Current sender account Balance: 7, Amount+Fee: 11", discardedL2Txs[0].Info)
	assert.Equal(t, 11, discardedL2Txs[0].ErrorCode)
	assert.Equal(t, "ErrSenderNotEnoughBalance", discardedL2Txs[0].ErrorType)
	assert.Equal(t, "Tx not selected due to not current Nonce. Tx.Nonce: 2, Account.Nonce: 1",
		discardedL2Txs[1].Info)
	assert.Equal(t, 12, discardedL2Txs[1].ErrorCode)
	assert.Equal(t, "ErrNoCurrentNonce", discardedL2Txs[1].ErrorType)

	err = txsel.l2db.StartForging(common.TxIDsFromPoolL2Txs(oL2Txs),
		txsel.localAccountsDB.CurrentBatch())
	require.NoError(t, err)

	stateDB.Close()
	txsel.LocalAccountsDB().Close()
}

func TestValidTxsWithLowFeeAndInvalidTxsWithHighFee(t *testing.T) {
	// This test recreates the case where there are

	set := `
		Type: Blockchain

		CreateAccountDeposit(0) Coord: 0
		CreateAccountDeposit(0) A: 100
		CreateAccountDeposit(0) B: 0

		> batchL1 // Batch1: freeze L1User{3}
		> batchL1 // Batch2: forge L1User{3}
		> block
	`

	chainID := uint16(0)
	tc := til.NewContext(chainID, common.RollupConstMaxL1UserTx)
	tilCfgExtra := til.ConfigExtra{
		BootCoordAddr: ethCommon.HexToAddress("0xE39fEc6224708f0772D2A74fd3f9055A90E0A9f2"),
		CoordUser:     "Coord",
	}
	blocks, err := tc.GenerateBlocks(set)
	require.NoError(t, err)
	err = tc.FillBlocksExtra(blocks, &tilCfgExtra)
	require.NoError(t, err)
	err = tc.FillBlocksForgedL1UserTxs(blocks)
	require.NoError(t, err)

	hermezContractAddr := ethCommon.HexToAddress("0xc344E203a046Da13b0B4467EB7B3629D0C99F6E6")
	txsel, historyDB, stateDB := initTest(t, chainID, hermezContractAddr, tc.Users["Coord"])

	// Insert blocks into DB
	for i := range blocks {
		err = historyDB.AddBlockSCData(&blocks[i])
		assert.NoError(t, err)
	}

	err = historyDB.UpdateTokenValue(common.EmptyAddr, 1000)
	require.NoError(t, err)

	// restart nonces of TilContext, as will be set by generating directly
	// the PoolL2Txs for each specific batch with tc.GeneratePoolL2Txs
	tc.RestartNonces()

	tpc := txprocessor.Config{
		NLevels:  16,
		MaxFeeTx: 5,
		MaxTx:    5,
		MaxL1Tx:  3,
		ChainID:  chainID,
	}
	// batch1 to freeze L1UserTxs
	l1UserTxs := []common.L1Tx{}
	_, _, _, _, _, _, err = txsel.GetL1L2TxSelection(tpc, l1UserTxs, nil)
	require.NoError(t, err)

	// batch 2 to crate the accounts (from L1UserTxs)
	l1UserTxs = til.L1TxsToCommonL1Txs(tc.Queues[*blocks[0].Rollup.Batches[1].Batch.ForgeL1TxsNum])

	// select L1 & L2 txs
	_, accAuths, oL1UserTxs, oL1CoordTxs, oL2Txs, discardedL2Txs, err :=
		txsel.GetL1L2TxSelection(tpc, l1UserTxs, nil)
	require.NoError(t, err)
	require.Equal(t, 3, len(oL1UserTxs))
	require.Equal(t, 0, len(oL1CoordTxs))
	require.Equal(t, 0, len(oL2Txs))
	require.Equal(t, 0, len(discardedL2Txs))
	require.Equal(t, 0, len(accAuths))

	err = txsel.l2db.StartForging(common.TxIDsFromPoolL2Txs(oL2Txs),
		txsel.localAccountsDB.CurrentBatch())
	require.NoError(t, err)

	batchPoolL2 := `
	Type: PoolL2
	PoolTransfer(0) B-A: 40 (130) // B-A txs are only possible once A-B txs are processed
	PoolTransfer(0) B-A: 1 (126)
	PoolTransfer(0) B-A: 1 (126)
	PoolTransfer(0) B-A: 1 (126)
	PoolTransfer(0) B-A: 1 (126)
	PoolTransfer(0) B-A: 1 (126)
	PoolTransfer(0) B-A: 1 (126)
	PoolTransfer(0) B-A: 1 (126)
	PoolTransfer(0) A-B: 20 (20)
	PoolTransfer(0) A-B: 25 (150)
	PoolTransfer(0) A-B: 20 (20)
	`
	poolL2Txs, err := tc.GeneratePoolL2Txs(batchPoolL2)
	require.NoError(t, err)
	require.Equal(t, 11, len(poolL2Txs))
	// add the PoolL2Txs to the l2DB
	addL2Txs(t, txsel, poolL2Txs)
	l1UserTxs = []common.L1Tx{}
	_, accAuths, oL1UserTxs, oL1CoordTxs, oL2Txs, discardedL2Txs, err =
		txsel.GetL1L2TxSelection(tpc, l1UserTxs, nil)
	require.NoError(t, err)

	require.Equal(t, 0, len(oL1UserTxs))
	require.Equal(t, 0, len(oL1CoordTxs))
	require.Equal(t, 5, len(oL2Txs))         // the 3 txs A-B
	require.Equal(t, 6, len(discardedL2Txs)) // the 8 txs B-A
	require.Equal(t, 0, len(accAuths))

	err = txsel.l2db.StartForging(common.TxIDsFromPoolL2Txs(oL2Txs),
		txsel.localAccountsDB.CurrentBatch())
	require.NoError(t, err)

	// batch 4. In this Batch, account B has enough balance to send the txs
	_, accAuths, oL1UserTxs, oL1CoordTxs, oL2Txs, discardedL2Txs, err =
		txsel.GetL1L2TxSelection(tpc, l1UserTxs, nil)
	require.NoError(t, err)

	require.Equal(t, 0, len(oL1UserTxs))
	require.Equal(t, 0, len(oL1CoordTxs))
	require.Equal(t, 5, len(oL2Txs))
	require.Equal(t, 1, len(discardedL2Txs))
	require.Equal(t, 0, len(accAuths))

	stateDB.Close()
	txsel.LocalAccountsDB().Close()
}

func TestL1UserFutureTxs(t *testing.T) {
	set := `
		Type: Blockchain

		CreateAccountDeposit(0) Coord: 0
		CreateAccountDeposit(0) A: 100

		> batchL1 // freeze L1User{2}
		CreateAccountDeposit(0) B: 18
		> batchL1 // forge L1User{2}, freeze L1User{1}
		> batchL1 // forge L1User{1}
		> block
	`

	chainID := uint16(0)
	tc := til.NewContext(chainID, common.RollupConstMaxL1UserTx)
	blocks, err := tc.GenerateBlocks(set)
	assert.NoError(t, err)

	hermezContractAddr := ethCommon.HexToAddress("0xc344E203a046Da13b0B4467EB7B3629D0C99F6E6")
	txsel, _, stateDB := initTest(t, chainID, hermezContractAddr, tc.Users["Coord"])

	// restart nonces of TilContext, as will be set by generating directly
	// the PoolL2Txs for each specific batch with tc.GeneratePoolL2Txs
	tc.RestartNonces()

	tpc := txprocessor.Config{
		NLevels:  16,
		MaxFeeTx: 10,
		MaxTx:    10,
		MaxL1Tx:  10,
		ChainID:  chainID,
	}
	// batch1 to freeze L1UserTxs
	l1UserTxs := []common.L1Tx{}
	l1UserFutureTxs := []common.L1Tx{}
	_, _, _, _, _, _, err = txsel.GetL1L2TxSelection(tpc, l1UserTxs, l1UserFutureTxs)
	require.NoError(t, err)

	batchPoolL2 := `
	Type: PoolL2
	PoolTransferToEthAddr(0) A-B: 10 (126)
	`
	poolL2Txs, err := tc.GeneratePoolL2Txs(batchPoolL2)
	require.NoError(t, err)
	require.Equal(t, 1, len(poolL2Txs))

	// add AccountCreationAuth for B
	_ = addAccCreationAuth(t, tc, txsel, chainID, hermezContractAddr, "B")
	// add the PoolL2Txs to the l2DB
	addL2Txs(t, txsel, poolL2Txs)
	// batch 2 to crate some accounts with positive balance, and do 1 L2Tx transfer from account A
	l1UserTxs = til.L1TxsToCommonL1Txs(tc.Queues[*blocks[0].Rollup.Batches[1].Batch.ForgeL1TxsNum])
	l1UserFutureTxs =
		til.L1TxsToCommonL1Txs(tc.Queues[*blocks[0].Rollup.Batches[2].Batch.ForgeL1TxsNum])
	require.Equal(t, 2, len(l1UserTxs))
	require.Equal(t, 1, len(l1UserFutureTxs))
	_, _, oL1UserTxs, oL1CoordTxs, oL2Txs, discardedL2Txs, err :=
		txsel.GetL1L2TxSelection(tpc, l1UserTxs, l1UserFutureTxs)
	require.NoError(t, err)
	assert.Equal(t, 2, len(oL1UserTxs))
	require.Equal(t, 0, len(oL1CoordTxs))
	// no L2Tx selected due the L1UserFutureTx, the L2Tx will be processed
	// at the next batch once the L1UserTx of CreateAccount B is processed,
	// despite that there is an AccountCreationAuth for Account B.
	assert.Equal(t, 0, len(oL2Txs))
	assert.Equal(t, 1, len(discardedL2Txs))
	assert.Equal(t, "Tx not selected (in processTxToEthAddrBJJ) due to "+
		"L2Tx discarded at the current batch, as the receiver account does not exist yet, "+
		"and there is a L1UserTx that will create that account in a future batch.",
		discardedL2Txs[0].Info)
	assert.Equal(t, 14, discardedL2Txs[0].ErrorCode)
	assert.Equal(t, "ErrTxDiscartedInProcessTxToEthAddrBJJ", discardedL2Txs[0].ErrorType)

	err = txsel.l2db.StartForging(common.TxIDsFromPoolL2Txs(oL2Txs),
		txsel.localAccountsDB.CurrentBatch())
	require.NoError(t, err)

	l1UserTxs = til.L1TxsToCommonL1Txs(tc.Queues[*blocks[0].Rollup.Batches[2].Batch.ForgeL1TxsNum])
	l1UserFutureTxs = []common.L1Tx{}
	_, _, oL1UserTxs, oL1CoordTxs, oL2Txs, discardedL2Txs, err =
		txsel.GetL1L2TxSelection(tpc, l1UserTxs, l1UserFutureTxs)
	require.NoError(t, err)
	assert.Equal(t, 1, len(oL1UserTxs))
	require.Equal(t, 0, len(oL1CoordTxs))
	// L2Tx selected as now the L1UserTx of CreateAccount B is processed
	assert.Equal(t, 1, len(oL2Txs))
	assert.Equal(t, 0, len(discardedL2Txs))
	err = txsel.l2db.StartForging(common.TxIDsFromPoolL2Txs(oL2Txs),
		txsel.localAccountsDB.CurrentBatch())
	require.NoError(t, err)

	// generate a new L2Tx A-B and check that is processed
	poolL2Txs, err = tc.GeneratePoolL2Txs(batchPoolL2)
	require.NoError(t, err)
	require.Equal(t, 1, len(poolL2Txs))
	// add the PoolL2Txs to the l2DB
	addL2Txs(t, txsel, poolL2Txs)
	_, _, oL1UserTxs, oL1CoordTxs, oL2Txs, discardedL2Txs, err =
		txsel.GetL1L2TxSelection(tpc, nil, nil)
	require.NoError(t, err)
	assert.Equal(t, 0, len(oL1UserTxs))
	require.Equal(t, 0, len(oL1CoordTxs))
	assert.Equal(t, 1, len(oL2Txs))
	assert.Equal(t, 0, len(discardedL2Txs))
	err = txsel.l2db.StartForging(common.TxIDsFromPoolL2Txs(oL2Txs),
		txsel.localAccountsDB.CurrentBatch())
	require.NoError(t, err)

	stateDB.Close()
	txsel.LocalAccountsDB().Close()
}

func TestSimpleAtomicTx(t *testing.T) {
	// This test will perform the most simple atomic tx case:
	// 1. Create three accounts (with deposit) for the same token: one for coordinator and two for users
	// 2. Each account will do a transfer to the other account and request the other tx.
	//    AccountA does tx 1 to AccountB requesting tx 2. AccountB does tx 2 to AccountA requesting tx 1.

	// Use til to create the account deposits
	chainID := uint16(0)
	tc := til.NewContext(chainID, common.RollupConstMaxL1UserTx)
	blocks, err := tc.GenerateBlocks(`
		Type: Blockchain
		> batch
		CreateAccountDeposit(0) Coord: 1000
		CreateAccountDeposit(0) A: 500
		CreateAccountDeposit(0) B: 300
		> batchL1
		> batchL1
		> batchL1
		> block
	`)
	require.NoError(t, err)

	hermezContractAddr := ethCommon.HexToAddress("0xc344E203a046Da13b0B4467EB7B3629D0C99F6E6")
	txsel, _, _ := initTest(t, chainID, hermezContractAddr, tc.Users["Coord"])

	tpc := txprocessor.Config{
		NLevels:  16,
		MaxFeeTx: 10,
		MaxTx:    20,
		MaxL1Tx:  10,
		ChainID:  chainID,
	}

	// Forge the 3 first batches, to reach the point were accounts are created
	log.Debug("block:0 batch:1")
	l1UserTxs := []common.L1Tx{}
	_, _, oL1UserTxs, oL1CoordTxs, oL2Txs, _, err :=
		txsel.GetL1L2TxSelection(tpc, l1UserTxs, nil)
	require.NoError(t, err)
	assert.Equal(t, 0, len(oL1UserTxs))
	assert.Equal(t, 0, len(oL1CoordTxs))
	assert.Equal(t, 0, len(oL2Txs))
	assert.Equal(t, common.BatchNum(1), txsel.localAccountsDB.CurrentBatch())
	assert.Equal(t, common.Idx(255), txsel.localAccountsDB.CurrentIdx())

	log.Debug("block:0 batch:2")
	l1UserTxs = []common.L1Tx{}
	_, _, oL1UserTxs, oL1CoordTxs, oL2Txs, _, err =
		txsel.GetL1L2TxSelection(tpc, l1UserTxs, nil)
	require.NoError(t, err)
	assert.Equal(t, 0, len(oL1UserTxs))
	assert.Equal(t, 0, len(oL1CoordTxs))
	assert.Equal(t, 0, len(oL2Txs))
	assert.Equal(t, common.BatchNum(2), txsel.localAccountsDB.CurrentBatch())
	assert.Equal(t, common.Idx(255), txsel.localAccountsDB.CurrentIdx())

	log.Debug("block:0 batch:3")
	l1UserTxs = til.L1TxsToCommonL1Txs(tc.Queues[*blocks[0].Rollup.Batches[2].Batch.ForgeL1TxsNum])
	_, _, oL1UserTxs, oL1CoordTxs, oL2Txs, _, err =
		txsel.GetL1L2TxSelection(tpc, l1UserTxs, nil)
	require.NoError(t, err)
	assert.Equal(t, 3, len(oL1UserTxs))
	assert.Equal(t, 0, len(oL1CoordTxs))
	assert.Equal(t, 0, len(oL2Txs))
	assert.Equal(t, common.BatchNum(3), txsel.localAccountsDB.CurrentBatch())
	assert.Equal(t, common.Idx(258), txsel.localAccountsDB.CurrentIdx())
	checkBalance(t, tc, txsel, "Coord", 0, "1000")
	checkBalance(t, tc, txsel, "A", 0, "500")
	checkBalance(t, tc, txsel, "B", 0, "300")

	// Generate the simple atomic txs
	agid := common.AtomicGroupID([common.AtomicGroupIDLen]byte{1})
	// Tx1 fields
	tx1 := common.PoolL2Tx{
		FromIdx:       257, // account A
		ToIdx:         258, // account B
		TokenID:       0,
		Amount:        big.NewInt(100),
		Fee:           0,
		Nonce:         0,
		RqOffset:      1, // Request tx bellow (position +1)
		AtomicGroupID: agid,
		RqFromIdx:     258, // account B
		RqToIdx:       257, // account A
		RqTokenID:     0,
		RqAmount:      big.NewInt(200),
		RqFee:         0,
		RqNonce:       0,
		State:         common.PoolL2TxStatePending,
	}
	// Tx1 signature
	_, err = common.NewPoolL2Tx(&tx1)
	require.NoError(t, err)
	hashTx1, err := tx1.HashToSign(chainID)
	require.NoError(t, err)
	accAWallet := til.NewUser(2, "A")
	tx1.Signature = accAWallet.BJJ.SignPoseidon(hashTx1).Compress()
	// Tx2 fields
	tx2 := common.PoolL2Tx{
		FromIdx:       258, // account B
		ToIdx:         257, // account A
		TokenID:       0,
		Amount:        big.NewInt(200),
		Fee:           0,
		Nonce:         0,
		RqOffset:      7, // Request tx above (position -1)
		AtomicGroupID: agid,
		RqFromIdx:     257, // account A
		RqToIdx:       258, // account B
		RqTokenID:     0,
		RqAmount:      big.NewInt(100),
		RqFee:         0,
		RqNonce:       0,
		State:         common.PoolL2TxStatePending,
	}
	// Tx2 signature
	_, err = common.NewPoolL2Tx(&tx2)
	require.NoError(t, err)
	hashTx2, err := tx2.HashToSign(chainID)
	require.NoError(t, err)
	accBWallet := til.NewUser(3, "B")
	tx2.Signature = accBWallet.BJJ.SignPoseidon(hashTx2).Compress()

	// Add txs to the pool
	addL2Txs(t, txsel, []common.PoolL2Tx{tx1, tx2})

	log.Debug("block:1 batch:4")
	_, _, oL1UserTxs, oL1CoordTxs, oL2Txs, _, err =
		txsel.GetL1L2TxSelection(tpc, nil, nil)
	require.NoError(t, err)
	assert.Equal(t, 0, len(oL1UserTxs))
	assert.Equal(t, 0, len(oL1CoordTxs))
	assert.Equal(t, 2, len(oL2Txs))
	assert.Equal(t, common.BatchNum(4), txsel.localAccountsDB.CurrentBatch())
	assert.Equal(t, common.Idx(258), txsel.localAccountsDB.CurrentIdx())
	checkBalance(t, tc, txsel, "Coord", 0, "1000")
	checkBalance(t, tc, txsel, "A", 0, "600") // 500 -100 +200
	checkBalance(t, tc, txsel, "B", 0, "200") // 300 +100 -200
}

func TestFailingAtomicTx(t *testing.T) {
	// This test will atempt to select an atomic group, which will be rejected due to insufficient balance:
	// 1. Create four accounts (with deposit) for the same token: one for coordinator and three for users
	// 2. Account A and B will atempt to do an atomic tx, first tx will be valid, but the 2nd won't have enough funds.
	//    Account C will send a transfer to account Coord, just to check that even with invalid atomic txs, the batch can still forge valid txs

	// Use til to create the account deposits
	chainID := uint16(0)
	tc := til.NewContext(chainID, common.RollupConstMaxL1UserTx)
	blocks, err := tc.GenerateBlocks(`
		Type: Blockchain
		> batch
		CreateAccountDeposit(0) Coord: 1000
		CreateAccountDeposit(0) A: 500
		CreateAccountDeposit(0) B: 300
		CreateAccountDeposit(0) C: 300
		> batchL1
		> batchL1
		> batchL1
		> block
	`)
	require.NoError(t, err)

	hermezContractAddr := ethCommon.HexToAddress("0xc344E203a046Da13b0B4467EB7B3629D0C99F6E6")
	txsel, _, _ := initTest(t, chainID, hermezContractAddr, tc.Users["Coord"])

	tpc := txprocessor.Config{
		NLevels:  16,
		MaxFeeTx: 10,
		MaxTx:    20,
		MaxL1Tx:  10,
		ChainID:  chainID,
	}

	// Forge the 3 first batches, to reach the point were accounts are created
	log.Debug("block:0 batch:1")
	l1UserTxs := []common.L1Tx{}
	_, _, oL1UserTxs, oL1CoordTxs, oL2Txs, _, err :=
		txsel.GetL1L2TxSelection(tpc, l1UserTxs, nil)
	require.NoError(t, err)
	assert.Equal(t, 0, len(oL1UserTxs))
	assert.Equal(t, 0, len(oL1CoordTxs))
	assert.Equal(t, 0, len(oL2Txs))
	assert.Equal(t, common.BatchNum(1), txsel.localAccountsDB.CurrentBatch())
	assert.Equal(t, common.Idx(255), txsel.localAccountsDB.CurrentIdx())

	log.Debug("block:0 batch:2")
	l1UserTxs = []common.L1Tx{}
	_, _, oL1UserTxs, oL1CoordTxs, oL2Txs, _, err =
		txsel.GetL1L2TxSelection(tpc, l1UserTxs, nil)
	require.NoError(t, err)
	assert.Equal(t, 0, len(oL1UserTxs))
	assert.Equal(t, 0, len(oL1CoordTxs))
	assert.Equal(t, 0, len(oL2Txs))
	assert.Equal(t, common.BatchNum(2), txsel.localAccountsDB.CurrentBatch())
	assert.Equal(t, common.Idx(255), txsel.localAccountsDB.CurrentIdx())

	log.Debug("block:0 batch:3")
	l1UserTxs = til.L1TxsToCommonL1Txs(tc.Queues[*blocks[0].Rollup.Batches[2].Batch.ForgeL1TxsNum])
	_, _, oL1UserTxs, oL1CoordTxs, oL2Txs, _, err =
		txsel.GetL1L2TxSelection(tpc, l1UserTxs, nil)
	require.NoError(t, err)
	assert.Equal(t, 4, len(oL1UserTxs))
	assert.Equal(t, 0, len(oL1CoordTxs))
	assert.Equal(t, 0, len(oL2Txs))
	assert.Equal(t, common.BatchNum(3), txsel.localAccountsDB.CurrentBatch())
	assert.Equal(t, common.Idx(259), txsel.localAccountsDB.CurrentIdx())
	checkBalance(t, tc, txsel, "Coord", 0, "1000")
	checkBalance(t, tc, txsel, "A", 0, "500")
	checkBalance(t, tc, txsel, "B", 0, "300")
	checkBalance(t, tc, txsel, "C", 0, "300")

	// Generate the failing atomic txs + one simple valid tx
	agid := common.AtomicGroupID([common.AtomicGroupIDLen]byte{1})
	// Tx1 fields
	tx1 := common.PoolL2Tx{
		FromIdx:       257, // account A (balance 500)
		ToIdx:         258, // account B
		TokenID:       0,
		Amount:        big.NewInt(50), // Ok
		Fee:           0,
		Nonce:         1,
		RqOffset:      1, // Request tx bellow (position +1)
		AtomicGroupID: agid,
		RqFromIdx:     258, // account B
		RqToIdx:       257, // account A
		RqTokenID:     0,
		RqAmount:      big.NewInt(400),
		RqFee:         0,
		RqNonce:       0,
		State:         common.PoolL2TxStatePending,
	}
	// Tx1 signature
	_, err = common.NewPoolL2Tx(&tx1)
	require.NoError(t, err)
	hashTx1, err := tx1.HashToSign(chainID)
	require.NoError(t, err)
	accAWallet := til.NewUser(2, "A")
	tx1.Signature = accAWallet.BJJ.SignPoseidon(hashTx1).Compress()
	// Tx2 fields
	tx2 := common.PoolL2Tx{
		FromIdx:       258, // account B (balance 350, as the previous tx will be already processed)
		ToIdx:         257, // account A
		TokenID:       0,
		Amount:        big.NewInt(400),
		Fee:           0,
		Nonce:         0,
		RqOffset:      7, // Request tx above (position -1)
		AtomicGroupID: agid,
		RqFromIdx:     257, // account A
		RqToIdx:       258, // account B
		RqTokenID:     0,
		RqAmount:      big.NewInt(50), // OK
		RqFee:         0,
		RqNonce:       1,
		State:         common.PoolL2TxStatePending,
	}
	// Tx2 signature
	_, err = common.NewPoolL2Tx(&tx2)
	require.NoError(t, err)
	hashTx2, err := tx2.HashToSign(chainID)
	require.NoError(t, err)
	accBWallet := til.NewUser(3, "B")
	tx2.Signature = accBWallet.BJJ.SignPoseidon(hashTx2).Compress()
	// Tx3 fields
	tx3 := common.PoolL2Tx{
		FromIdx: 259, // account C
		ToIdx:   256, // account Coord
		TokenID: 0,
		Amount:  big.NewInt(10),
		Fee:     0,
		Nonce:   0,
		State:   common.PoolL2TxStatePending,
	}
	// Tx3 signature
	_, err = common.NewPoolL2Tx(&tx3)
	require.NoError(t, err)
	hashTx3, err := tx3.HashToSign(chainID)
	require.NoError(t, err)
	accCWallet := til.NewUser(4, "C")
	tx3.Signature = accCWallet.BJJ.SignPoseidon(hashTx3).Compress()

	// Add txs to the pool
	addL2Txs(t, txsel, []common.PoolL2Tx{tx1, tx2, tx3})

	log.Debug("block:1 batch:4")
	_, _, oL1UserTxs, oL1CoordTxs, oL2Txs, discardedL2Txs, err :=
		txsel.GetL1L2TxSelection(tpc, nil, nil)
	require.NoError(t, err)
	assert.Equal(t, 0, len(oL1UserTxs))
	assert.Equal(t, 0, len(oL1CoordTxs))
	assert.Equal(t, 1, len(oL2Txs))
	assert.Equal(t, 2, len(discardedL2Txs))

	for _, tx := range discardedL2Txs {
		if tx1.TxID == tx.TxID {
			assert.Equal(t, ErrNoCurrentNonceType, tx.ErrorType)
		} else if tx2.TxID == tx.TxID {
			assert.Equal(t, ErrInvalidAtomicGroupType, tx.ErrorType)
		} else {
			assert.Fail(t, "unexpected transaction")
		}
	}

	assert.Equal(t, common.BatchNum(4), txsel.localAccountsDB.CurrentBatch())
	assert.Equal(t, common.Idx(259), txsel.localAccountsDB.CurrentIdx())
	checkBalance(t, tc, txsel, "Coord", 0, "1010") // 1000 + 10
	checkBalance(t, tc, txsel, "A", 0, "500")      // Balance not affected due to rejected atomic txs
	checkBalance(t, tc, txsel, "B", 0, "300")      // Balance not affected due to rejected atomic txs
	checkBalance(t, tc, txsel, "C", 0, "290")      // 300 - 10
}

func TestFilterMaxNumBatch(t *testing.T) {
	// This test will check that txs are rejected if MaxNumBatch is exceeded

	// Use til to create the account deposits
	chainID := uint16(0)
	tc := til.NewContext(chainID, common.RollupConstMaxL1UserTx)
	blocks, err := tc.GenerateBlocks(`
		Type: Blockchain
		> batch
		CreateAccountDeposit(0) Coord: 1000
		CreateAccountDeposit(0) A: 500
		CreateAccountDeposit(0) B: 300
		> batchL1
		> batchL1
		> batchL1
		> block
	`)
	require.NoError(t, err)

	hermezContractAddr := ethCommon.HexToAddress("0xc344E203a046Da13b0B4467EB7B3629D0C99F6E6")
	txsel, _, _ := initTest(t, chainID, hermezContractAddr, tc.Users["Coord"])

	tpc := txprocessor.Config{
		NLevels:  16,
		MaxFeeTx: 10,
		MaxTx:    20,
		MaxL1Tx:  10,
		ChainID:  chainID,
	}

	// Forge the 3 first batches, to reach the point were accounts are created
	log.Debug("block:0 batch:1")
	l1UserTxs := []common.L1Tx{}
	_, _, oL1UserTxs, oL1CoordTxs, oL2Txs, _, err :=
		txsel.GetL1L2TxSelection(tpc, l1UserTxs, nil)
	require.NoError(t, err)
	assert.Equal(t, 0, len(oL1UserTxs))
	assert.Equal(t, 0, len(oL1CoordTxs))
	assert.Equal(t, 0, len(oL2Txs))
	assert.Equal(t, common.BatchNum(1), txsel.localAccountsDB.CurrentBatch())
	assert.Equal(t, common.Idx(255), txsel.localAccountsDB.CurrentIdx())

	log.Debug("block:0 batch:2")
	l1UserTxs = []common.L1Tx{}
	_, _, oL1UserTxs, oL1CoordTxs, oL2Txs, _, err =
		txsel.GetL1L2TxSelection(tpc, l1UserTxs, nil)
	require.NoError(t, err)
	assert.Equal(t, 0, len(oL1UserTxs))
	assert.Equal(t, 0, len(oL1CoordTxs))
	assert.Equal(t, 0, len(oL2Txs))
	assert.Equal(t, common.BatchNum(2), txsel.localAccountsDB.CurrentBatch())
	assert.Equal(t, common.Idx(255), txsel.localAccountsDB.CurrentIdx())

	log.Debug("block:0 batch:3")
	l1UserTxs = til.L1TxsToCommonL1Txs(tc.Queues[*blocks[0].Rollup.Batches[2].Batch.ForgeL1TxsNum])
	_, _, oL1UserTxs, oL1CoordTxs, oL2Txs, _, err =
		txsel.GetL1L2TxSelection(tpc, l1UserTxs, nil)
	require.NoError(t, err)
	assert.Equal(t, 3, len(oL1UserTxs))
	assert.Equal(t, 0, len(oL1CoordTxs))
	assert.Equal(t, 0, len(oL2Txs))
	assert.Equal(t, common.BatchNum(3), txsel.localAccountsDB.CurrentBatch())
	assert.Equal(t, common.Idx(258), txsel.localAccountsDB.CurrentIdx())
	checkBalance(t, tc, txsel, "Coord", 0, "1000")
	checkBalance(t, tc, txsel, "A", 0, "500")
	checkBalance(t, tc, txsel, "B", 0, "300")

	// Tx1 fields (this tx won't be processed due to MaxNumBatch > current batch num)
	tx1 := common.PoolL2Tx{
		FromIdx:     257, // account A
		ToIdx:       258, // account B
		TokenID:     0,
		Amount:      big.NewInt(100),
		Fee:         0,
		Nonce:       0,
		MaxNumBatch: 3,
		State:       common.PoolL2TxStatePending,
	}
	// Tx1 signature
	_, err = common.NewPoolL2Tx(&tx1)
	require.NoError(t, err)
	hashTx1, err := tx1.HashToSign(chainID)
	require.NoError(t, err)
	accAWallet := til.NewUser(2, "A")
	tx1.Signature = accAWallet.BJJ.SignPoseidon(hashTx1).Compress()
	// Tx2 fields
	tx2 := common.PoolL2Tx{
		FromIdx:     258, // account B
		ToIdx:       257, // account A
		TokenID:     0,
		Amount:      big.NewInt(200),
		Fee:         0,
		Nonce:       0,
		MaxNumBatch: 4,
		State:       common.PoolL2TxStatePending,
	}
	// Tx2 signature
	_, err = common.NewPoolL2Tx(&tx2)
	require.NoError(t, err)
	hashTx2, err := tx2.HashToSign(chainID)
	require.NoError(t, err)
	accBWallet := til.NewUser(3, "B")
	tx2.Signature = accBWallet.BJJ.SignPoseidon(hashTx2).Compress()

	// Add txs to the pool
	addL2Txs(t, txsel, []common.PoolL2Tx{tx1, tx2})

	log.Debug("block:1 batch:4")
	_, _, oL1UserTxs, oL1CoordTxs, oL2Txs, discardedL2Txs, err :=
		txsel.GetL1L2TxSelection(tpc, nil, nil)
	require.NoError(t, err)
	assert.Equal(t, 0, len(oL1UserTxs))
	assert.Equal(t, 0, len(oL1CoordTxs))
	assert.Equal(t, 1, len(oL2Txs))
	assert.Equal(t, 1, len(discardedL2Txs))
	assert.Equal(t, "MaxNumBatch exceeded", discardedL2Txs[0].Info)
	assert.Equal(t, 2, discardedL2Txs[0].ErrorCode)
	assert.Equal(t, "ErrUnsupportedMaxNumBatch", discardedL2Txs[0].ErrorType)
	assert.Equal(t, common.BatchNum(4), txsel.localAccountsDB.CurrentBatch())
	assert.Equal(t, common.Idx(258), txsel.localAccountsDB.CurrentIdx())
	checkBalance(t, tc, txsel, "Coord", 0, "1000")
	checkBalance(t, tc, txsel, "A", 0, "700") // 500 +200
	checkBalance(t, tc, txsel, "B", 0, "100") // 300 -200
}

func TestFilterFailedAtomicGroups(t *testing.T) {
	// Helper function to perform asserts
	assertResult := func(
		t *testing.T,
		expectedSelectedTxIDs, expectedFilteredTxIDs []common.TxID,
		actualSelected, actualFiltered []common.PoolL2Tx,
	) {
		// Check if expected and actual have the same amount of items
		assert.Equal(t, len(expectedSelectedTxIDs), len(actualSelected))
		assert.Equal(t, len(expectedFilteredTxIDs), len(actualFiltered))
		// Check if the TxIDs of the slected txs much the expectations
		for i, txID := range expectedSelectedTxIDs {
			assert.Equal(t, txID, actualSelected[i].TxID)
		}
		// Check if the TxIDs of the slected txs much the expectations
		for i, txID := range expectedFilteredTxIDs {
			assert.Equal(t, txID, actualFiltered[i].TxID)
		}
	}
	// TxIDs
	id1 := common.TxID([common.TxIDLen]byte{1})
	id2 := common.TxID([common.TxIDLen]byte{2})
	id3 := common.TxID([common.TxIDLen]byte{3})
	// AtomicGroupIDs
	agid1 := common.AtomicGroupID([common.AtomicGroupIDLen]byte{1})
	agid2 := common.AtomicGroupID([common.AtomicGroupIDLen]byte{2})

	// Case no failing groups
	txs := []common.PoolL2Tx{
		{
			TxID:          id1,
			AtomicGroupID: agid1,
		},
		{
			TxID:          id2,
			AtomicGroupID: common.EmptyAtomicGroupID,
		},
	}
	failedGroups := []failedAtomicGroup{}
	selected, filtered := filterFailedAtomicGroups(txs, failedGroups)
	assertResult(t, []common.TxID{id1, id2}, nil, selected, filtered)
	// Case all failing
	txs = []common.PoolL2Tx{
		{
			TxID:          id1,
			AtomicGroupID: agid1,
		},
		{
			TxID:          id2,
			AtomicGroupID: agid2,
		},
	}
	failedGroups = []failedAtomicGroup{{id: agid1}, {id: agid2}}
	selected, filtered = filterFailedAtomicGroups(txs, failedGroups)
	assertResult(t, nil, []common.TxID{id1, id2}, selected, filtered)
	// Case mixed
	txs = []common.PoolL2Tx{
		{
			TxID:          id1,
			AtomicGroupID: common.EmptyAtomicGroupID,
		},
		{
			TxID:          id2,
			AtomicGroupID: agid1,
		},
		{
			TxID:          id3,
			AtomicGroupID: agid2,
		},
	}
	failedGroups = []failedAtomicGroup{{id: agid1}}
	selected, filtered = filterFailedAtomicGroups(txs, failedGroups)
	assertResult(t, []common.TxID{id1, id3}, []common.TxID{id2}, selected, filtered)
}

func TestCalculateAtomicGroupsAverageFee(t *testing.T) {
	// AtomicGroupIDs
	agid1 := common.AtomicGroupID([common.AtomicGroupIDLen]byte{1})
	agid2 := common.AtomicGroupID([common.AtomicGroupIDLen]byte{2})
	agid3 := common.AtomicGroupID([common.AtomicGroupIDLen]byte{3})
	// Case no atomic groups
	txs := []common.PoolL2Tx{
		{
			AtomicGroupID: common.EmptyAtomicGroupID,
			AbsoluteFee:   1234.567,
		},
	}
	expected := make(map[common.AtomicGroupID]float64)
	actual := calculateAtomicGroupsAverageFee(txs)
	assert.Equal(t, expected, actual)
	// Case 3 ordered groups
	txs = []common.PoolL2Tx{
		{
			AtomicGroupID: common.EmptyAtomicGroupID,
			AbsoluteFee:   1234.567,
		},
		{
			AtomicGroupID: agid1,
			AbsoluteFee:   1.0,
		},
		{
			AtomicGroupID: agid2,
			AbsoluteFee:   2.0,
		},
		{
			AtomicGroupID: agid2,
			AbsoluteFee:   2.0,
		},
		{
			AtomicGroupID: agid3,
			AbsoluteFee:   3.0,
		},
		{
			AtomicGroupID: agid3,
			AbsoluteFee:   3.0,
		},
		{
			AtomicGroupID: agid3,
			AbsoluteFee:   3.0,
		},
	}
	expected = make(map[common.AtomicGroupID]float64)
	expected[agid1] = 1.0
	expected[agid2] = (2.0 + 2.0) / 2
	expected[agid3] = (3.0 + 3.0 + 3.0) / 3
	actual = calculateAtomicGroupsAverageFee(txs)
	assert.Equal(t, expected, actual)
	// Case 3 not ordered groups
	txs = []common.PoolL2Tx{
		{
			AtomicGroupID: common.EmptyAtomicGroupID,
			AbsoluteFee:   1234.567,
		},
		{
			AtomicGroupID: agid3,
			AbsoluteFee:   3.0,
		},
		{
			AtomicGroupID: agid2,
			AbsoluteFee:   2.0,
		},
		{
			AtomicGroupID: agid2,
			AbsoluteFee:   2.0,
		},
		{
			AtomicGroupID: agid3,
			AbsoluteFee:   3.0,
		},
		{
			AtomicGroupID: agid3,
			AbsoluteFee:   3.0,
		},
		{
			AtomicGroupID: agid1,
			AbsoluteFee:   1.0,
		},
	}
	expected = make(map[common.AtomicGroupID]float64)
	expected[agid1] = 1.0
	expected[agid2] = (2.0 + 2.0) / 2
	expected[agid3] = (3.0 + 3.0 + 3.0) / 3
	actual = calculateAtomicGroupsAverageFee(txs)
	assert.Equal(t, expected, actual)
}

func TestSortL2Txs(t *testing.T) {
	// Helper function to perform asserts
	assertResult := func(t *testing.T, expected []common.TxID, actual []common.PoolL2Tx) {
		assert.Equal(t, len(expected), len(actual))
		for i, a := range actual {
			assert.Equal(t, expected[i], a.TxID)
		}
	}

	//Idxs
	idx1 := common.Idx(256)
	idx2 := common.Idx(257)
	idx3 := common.Idx(258)
	idx4 := common.Idx(259)
	idx5 := common.Idx(260)
	idx6 := common.Idx(261)

	// TxIDs
	id1 := common.TxID([common.TxIDLen]byte{1})
	id2 := common.TxID([common.TxIDLen]byte{2})
	id3 := common.TxID([common.TxIDLen]byte{3})
	id4 := common.TxID([common.TxIDLen]byte{4})
	id5 := common.TxID([common.TxIDLen]byte{5})
	id6 := common.TxID([common.TxIDLen]byte{6})
	id7 := common.TxID([common.TxIDLen]byte{7})

	// AtomicGroupIDs
	agid1 := common.AtomicGroupID([common.AtomicGroupIDLen]byte{1})
	agid2 := common.AtomicGroupID([common.AtomicGroupIDLen]byte{2})
	// Case only non atomic
	txs := []common.PoolL2Tx{
		{
			TxID:          id1,
			FromIdx:       idx1,
			AtomicGroupID: common.EmptyAtomicGroupID,
			AbsoluteFee:   3,
			Nonce:         2,
		},
		{
			TxID:          id2,
			FromIdx:       idx1,
			AtomicGroupID: common.EmptyAtomicGroupID,
			AbsoluteFee:   3,
			Nonce:         1,
		},
		{
			TxID:          id3,
			FromIdx:       idx2,
			AtomicGroupID: common.EmptyAtomicGroupID,
			AbsoluteFee:   7,
			Nonce:         2,
		},
	}
	fees := calculateAtomicGroupsAverageFee(txs)
	actual := sortL2Txs(txs, fees)
	assertResult(t, []common.TxID{id3, id2, id1}, actual)
	// Case only atomic
	txs = []common.PoolL2Tx{
		{
			TxID:          id1,
			FromIdx:       idx1,
			AtomicGroupID: agid2,
			AbsoluteFee:   3,
			Nonce:         2220,
		},
		{
			TxID:          id2,
			FromIdx:       idx2,
			AtomicGroupID: agid2,
			AbsoluteFee:   3,
			Nonce:         1,
		},
		{
			TxID:          id3,
			FromIdx:       idx3,
			AtomicGroupID: agid1,
			AbsoluteFee:   7,
			Nonce:         300,
		},
		{
			TxID:          id4,
			FromIdx:       idx2,
			AtomicGroupID: agid1,
			AbsoluteFee:   700,
			Nonce:         2,
		},
	}
	fees = calculateAtomicGroupsAverageFee(txs)
	actual = sortL2Txs(txs, fees)
	assertResult(t, []common.TxID{id3, id4, id1, id2}, actual)
	// Case mixed
	txs = []common.PoolL2Tx{
		{
			TxID:          id1,
			FromIdx:       idx1,
			AtomicGroupID: agid2,
			AbsoluteFee:   20,
			Nonce:         2220,
		},
		{
			TxID:          id2,
			FromIdx:       idx2,
			AtomicGroupID: agid2,
			AbsoluteFee:   20,
			Nonce:         1,
		},
		{
			TxID:          id3,
			FromIdx:       idx3,
			AtomicGroupID: agid1,
			AbsoluteFee:   30,
			Nonce:         300,
		},
		{
			TxID:          id4,
			FromIdx:       idx2,
			AtomicGroupID: agid1,
			AbsoluteFee:   30,
			Nonce:         2,
		},
		{
			TxID:          id5,
			FromIdx:       idx4,
			AtomicGroupID: common.EmptyAtomicGroupID,
			AbsoluteFee:   25,
			Nonce:         2,
		},
		{
			TxID:          id6,
			FromIdx:       idx5,
			AtomicGroupID: common.EmptyAtomicGroupID,
			AbsoluteFee:   10,
			Nonce:         2,
		},
		{
			TxID:          id7,
			FromIdx:       idx6,
			AtomicGroupID: common.EmptyAtomicGroupID,
			AbsoluteFee:   35,
			Nonce:         2,
		},
	}
	fees = calculateAtomicGroupsAverageFee(txs)
	actual = sortL2Txs(txs, fees)
	assertResult(t, []common.TxID{id7, id3, id4, id5, id1, id2, id6}, actual)
}

func TestFilterInvalidAtomicGroups(t *testing.T) {
	// TxIDs
	id1 := common.TxID([common.TxIDLen]byte{1})
	id2 := common.TxID([common.TxIDLen]byte{2})
	id3 := common.TxID([common.TxIDLen]byte{3})
	id4 := common.TxID([common.TxIDLen]byte{4})
	id5 := common.TxID([common.TxIDLen]byte{5})
	id6 := common.TxID([common.TxIDLen]byte{6})
	id7 := common.TxID([common.TxIDLen]byte{7})
	id8 := common.TxID([common.TxIDLen]byte{8})
	id9 := common.TxID([common.TxIDLen]byte{9})
	id10 := common.TxID([common.TxIDLen]byte{10})
	id11 := common.TxID([common.TxIDLen]byte{11})
	id12 := common.TxID([common.TxIDLen]byte{12})
	// AtomicGroupIDs
	agid1 := common.AtomicGroupID([common.AtomicGroupIDLen]byte{1})
	agid2 := common.AtomicGroupID([common.AtomicGroupIDLen]byte{2})
	agid3 := common.AtomicGroupID([common.AtomicGroupIDLen]byte{3})
	agid4 := common.AtomicGroupID([common.AtomicGroupIDLen]byte{4})
	agid5 := common.AtomicGroupID([common.AtomicGroupIDLen]byte{5})
	// Helper to check result
	assertIds := func(t *testing.T, expected []common.TxID, actual []common.PoolL2Tx) {
		// Check 1: same amount of expected vs actual
		require.Equal(t, len(expected), len(actual))
		// Check 2: expected and actual have the same items (but maybe different order)
		for _, id := range expected {
			found := false
			for _, tx := range actual {
				if id == tx.TxID {
					found = true
					break
				}
			}
			assert.True(t, found)
		}
		// Check 3: order is preserved within atomic groups
		// Create atomic groups
		atomicGroups := make(map[common.AtomicGroupID]common.AtomicGroup)
		for i := range actual {
			atomicGroupID := actual[i].AtomicGroupID
			if atomicGroupID == common.EmptyAtomicGroupID {
				continue
			}
			if atomicGroup, ok := atomicGroups[atomicGroupID]; !ok {
				atomicGroups[atomicGroupID] = common.AtomicGroup{
					Txs: []common.PoolL2Tx{actual[i]},
				}
			} else {
				atomicGroup.Txs = append(atomicGroup.Txs, actual[i])
				atomicGroups[atomicGroupID] = atomicGroup
			}
		}
		for _, atomicGroup := range atomicGroups {
			var firstPositionInExpected int
			for j := range expected {
				if expected[j] == atomicGroup.Txs[0].TxID {
					firstPositionInExpected = j
					break
				}
			}
			for i, tx := range atomicGroup.Txs {
				assert.Equal(t, expected[firstPositionInExpected+i], tx.TxID)
			}
		}
	}

	// All groups invalid
	txs := []common.PoolL2Tx{
		{
			TxID:          id1,
			AtomicGroupID: agid1,
			RqOffset:      1,
		},
		{
			TxID:          id2,
			AtomicGroupID: agid1,
			RqOffset:      7,
			RqFromIdx:     777, // Missmatch of RqFromIdx
		},
		{
			TxID: id3,
		},
		{
			TxID:          id4,
			AtomicGroupID: agid2,
			RqOffset:      1,
		},
		{
			TxID:          id5,
			AtomicGroupID: agid2,
			RqOffset:      7,
			RqAmount:      big.NewInt(7), // Missmatch of RqFromIdx
		},
		{
			TxID:          id6,
			AtomicGroupID: agid3,
			RqOffset:      1,
		},
		{
			TxID:          id7,
			AtomicGroupID: agid3,
			RqOffset:      5, // Invalid RqOffset
		},
		{
			TxID: id8,
		},
		{
			TxID:          id9,
			AtomicGroupID: agid4,
			RqOffset:      1,
		},
		{
			TxID: id10,
		},
		{
			TxID:          id11,
			AtomicGroupID: agid5,
			RqOffset:      1,
			Fee:           123,
		},
		{
			TxID:          id12,
			AtomicGroupID: agid5,
			RqOffset:      7,
		},
	}
	valid, invalid := filterInvalidAtomicGroups(txs)
	assertIds(t, []common.TxID{id3, id8, id10}, valid)
	assertIds(t, []common.TxID{id1, id2, id4, id5, id6, id7, id9, id11, id12}, invalid)
	// All groups valid
	txs = []common.PoolL2Tx{
		{
			TxID:          id1,
			AtomicGroupID: agid1,
			RqOffset:      1,
		},
		{
			TxID:          id2,
			AtomicGroupID: agid1,
			RqOffset:      7,
		},
		{
			TxID: id3,
		},
		{
			TxID:          id4,
			AtomicGroupID: agid2,
			RqOffset:      1,
		},
		{
			TxID:          id5,
			AtomicGroupID: agid2,
			RqOffset:      7,
		},
		{
			TxID:          id6,
			AtomicGroupID: agid3,
			RqOffset:      1,
		},
		{
			TxID:          id7,
			AtomicGroupID: agid3,
			RqOffset:      7,
		},
		{
			TxID: id8,
		},
		{
			TxID:          id9,
			AtomicGroupID: agid4,
			RqOffset:      1,
		},
		{
			TxID:          id10,
			AtomicGroupID: agid4,
			RqOffset:      7,
		},
		{
			TxID:          id11,
			AtomicGroupID: agid5,
			RqOffset:      1,
		},
		{
			TxID:          id12,
			AtomicGroupID: agid5,
			RqOffset:      7,
		},
	}
	valid, invalid = filterInvalidAtomicGroups(txs)
	assertIds(t, []common.TxID{id1, id2, id3, id4, id5, id6, id7, id8, id9, id10, id11, id12}, valid)
	assertIds(t, []common.TxID{}, invalid)
}
